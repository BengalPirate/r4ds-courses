Data Transformation
========================================================
author: Alejandro Schuler, adapted from Steve Bagley and based on R for Data Science by Hadley Wickham
date: 2019
transition: none
width: 1680
height: 1050

```{r include=FALSE}
## better font size for slides
library(tidyverse)
theme_set(theme_grey(base_size = 22))
opts_chunk$set(collapse=TRUE,tidy=TRUE,prompt=TRUE,comment=NA,cache=FALSE)
opts_chunk$set(error=TRUE,warning=TRUE,message=TRUE)
```
<style>
.small-code pre code {
  font-size: 0.5em;
}
</style>

dplyr
========================================================
This section shows the basic data frame functions ("verbs") in the `dplyr` package (part of `tidyverse`).

<div align="center">
<img src="https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/dplyr.png"; style="max-width:800px;"; class="center">
</div>

dplyr verbs
========================================================
Each operation takes a data frame and produces a new data frame.

- `filter()` picks out rows according to specified conditions
- `select()` picks out columns according to their names
- `arrange()` sorts the row by values in some column(s)
- `mutate()` creates new columns, often based on operations on other columns
- `summarize()` collapses many values in one or more columns down to one value per column

These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation.

All verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes).
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result. Letâ€™s dive in and see how these verbs work.

Filter rows with filter()
====
type: section

Filter rows with filter()
========================================================
- `filter()` lets you filter out rows of a dataset that meet a certain condition
- it takes two arguments: the dataset and the condition

```{r}
nrow(mpg)
filter(mpg, hwy <= 25)
```

Exercise
========================================================
- What is the result of running this code?

```{r}
nrow(mpg)
```

```{r, eval=F}
filter(mpg, hwy <= 25)
filter(mpg, cyl <= 4)
nrow(mpg)
```

- remember, functions usually do not change their arguments!

```{r}
low_mileage = filter(mpg, hwy <= 25)
low_mileage_few_cyl = filter(low_mileage, cyl <= 4)
nrow(low_mileage_few_cyl)
```

Combining constraints in filter
========================================================
```{r}
filter(mpg, hwy <= 25, year>2000)
```
- This filters by the **conjunction** of the two constraints---both must be satisfied.
- Constraints appear as second (and third...) arguments, separated by commas.


Filtering out all rows
=========================================================
```{r}
filter(mpg, hwy > 60)
```
- If the constraint is too severe, then you will select **no** rows, and produce a zero row sized tibble.

Comparison operators
=========================================================
- `==` and `!=` test for equality and inequality (do not use `=` for equality)
- `>` and `<` test for greater-than and less-than
- `>=` and `<=` are greater-than-or-equal and less-than-or-equal
- these can also be used directly on vectors outside of data frames
```{r}
c(1,5,-22,4) > 0
```

<!-- Finite precision arithemetic -->
<!-- === -->
<!-- ```{r} -->
<!-- sqrt(2) ^ 2 == 2 -->
<!-- 1 / 49 * 49 == 1 -->
<!-- near(sqrt(2) ^ 2,  2) -->
<!-- near(1 / 49 * 49, 1) -->
<!-- ``` -->

Logical conjunctions
=========================================================
```{r}
filter(mpg, hwy > 30 | hwy < 20)
```
- `|` stands for OR, `&` is AND
- as we have seen, separating conditions by a comma is the same as using `&` inside `filter()`
- these can be made into complex logical conditions

Logical conjunctions
=========================================================
```{r}
filter(mpg, !(hwy > 30 | hwy < 20))
```
- `!` is NOT, which negates the logical condition

Logical conjunctions
=========================================================
```{r}
filter(mpg, cyl %in% c(6,8)) # equivalent to filter(mtc, cyl==6 | cyl==8)
```
- `%in%` returns true for all elements of the thing on the left that are also elements of the thing on the right

Exercise: Audis
==========================================================
type: prompt
incremental: true

- How many Audis are there in this dataset?
```{r}
nrow(filter(mpg, manufacturer=="audi"))
```

Filtering by row number
==========================================================
```{r}
filter(mpg, row_number()<=3)
```
- use `row_number()` to get specific rows. This is more useful once you have sorted the data in a particular order, which we will soon see how to do.

Sampling rows
==========================================================
```{r}
sample_n(mtc, 5)
```
- You can use `sample_n()` to get `n` randomly selected rows if you don't have a particular condition you would like to filter on.
- `sample_frac()` is similar
- do `?sample_n()` to see how you can sample with replacement or with weights

Arrange rows with arrange()
===
type:section

Arrange rows with arrange()
===========================================================
- `arrange()` takes a data frame and a column, and sorts the rows by the values in that column (ascending order).
- again, the first argument is the data frame and the other arguments tell the function what to do with it
```{r}
arrange(mpg, hwy)
```

Arrange can sort by more than one column
===========================================================
- This is useful if there is a tie in sorting by the first column.
```{r}
arrange(mpg, hwy, displ)
```


Use the desc function to sort by descending values
===========================================================
```{r}
arrange(mpg, desc(hwy))
```

Exercise: top 5 mpg cars
===========================================================
type:prompt
incremental:true

Use `arrange()` and `filter()` to get the data for the 5 cars with the highest highway MPG (`hwy`)

```{r}
filter(arrange(mpg, desc(hwy)), row_number()<=5) # "nesting" the calls to filter and arrange
```
or
```{r}
cars_by_mpg = arrange(mpg, desc(hwy)) # using a temporary variable
filter(cars_by_mpg, row_number()<=5)
```

Select columns with select()
===
type:section

Select columns with select()
=========================================================
```{r}
select(mpg, hwy, cyl, manufacturer)
```
- The select function will return a subset of the tibble, using only the requested columns in the order specified.

Select columns with select()
=========================================================
- `select()` can also be used with handy helpers like `starts_with()` and `contains()`
```{r}
select(mpg, starts_with("m"))
```
- Use `?select` to see all the possibilities

***

```{r}
select(mpg, contains("l"))
```
- The quotes around the letter `"l"` make it a string. If we did not do this, `R` would think it was looking for a variable called `m` and not just the plain letter.
- We don't have to quote the names of columns (like `hp`) because the `tidyverse` functions know that we are working within the dataframe and thus treat the column names like they are variables in their own right

select() subsets columns by name
=========================================================
- `select()` can also be used to select everything **except for** certain columns
```{r}
select(mpg, -contains("l"), -hwy)
```

select() subsets columns by name
=========================================================
- or even to select only columns that match a certain condition

```{r}
select(mpg, where(is.integer))
```

pull() is a friend of select()
=========================================================
- `select()` has a friend called `pull()` which returns a vector instead of a (one-column) data frame
```{r}
select(mpg, hwy)
pull(mpg, hwy)
```

rename()
=========================================================
- `select()` can be used to rename variables, but it drops all variables not selected
```{r}
select(mpg, hwy_milage = hwy)
```
***
- `rename()` is better suited for this because it keeps all the columns
```{r}
rename(mpg, hwy_milage = hwy)
```

select and filter
===
incremental:true
type:prompt

- create a one-column dataframe of the highway fuel efficiencies (`hwy`) of all of the compact cars (`class`) in the `mpg` dataset.

```{r}
select(filter(mpg, class == "compact"), hwy)
```

- what is wrong with this?
```{r, eval=F}
filter(select(mpg, hwy), class == "compact")
```


Add new variables with mutate()
===
type:section

Add new variables with mutate()
================================================================
```{r}
mpg_vars_subset = select(mpg, hwy, displ)
mutate(mtc_vars_subset, hw_gallons_per_mile = 1/hwy)
```
- This uses `mutate()` to add a new column to which is the reciprocal of `hwy`.
- The thing on the left of the `=` is a new name that you make up which you would like the new column to be called
- The expresssion on the right of the `=` defines what will go into the new column
-`mutate()` can create multiple columns at the same time and use multiple columns to define a single new one

mutate() can create multiple new columns at once
================================================================
```{r, tidy=F}
mutate(mpg_vars_subset, # the newlines make it more readable
      hw_gallons_per_mile = 1/hwy,
      mpg_displ_ratio = hwy/displ
)
```
- note that we have also used two columns simultaneously (`hwy` and `displ`) to create a new column)

mutate() for data type conversion
===
- Data is sometimes given to you in a form that makes it difficult to do operations on
```{r}
df = tibble(number = c("1", "2", "3"))
df
mutate(df, number_plus_1 = number + 1)
```

- `mutate()` is also useful for converting data types, in this case text to numbers
```{r}
mutate(df, number = as.numeric(number))
```
- if you save the result into a column that already exists, it will be overwritten

mutate() for computing offsets
===
incremental: true
```{r}
lead(c(1,2,3))
lag(c(1,2,3))
```

```{r, tidy=F}
scores = tibble(
  day = c(1,2,3,4),
  score = c(72, 87, 94, 99)
)
```

```{r}
mutate(scores, daily_improvement = score - lag(score))
```

mutate() for cumulative functions
===
incremental: true
```{r}
cumsum(c(1,2,3))
```
- `cumsum` takes the cumulative sum of a vector. See `?cumsum` for similar functions

```{r, tidy=F}
profits = tibble(
  day = c(1,2,3,4),
  profit = c(12, 40, 19, 13)
)
```

```{r}
mutate(profits, profit_to_date = cumsum(profit))
```

mutate() for rolling functions
===
incremental: true
```{r}
library("slider")
slide_vec(c(1,2,3,4), mean, .before=1)
```
- `slide_vec` applies a function using a sliding window across a vector (sometimes called "rolling" functions)

```{r, tidy=F}
profits = tibble(
  day = c(1,2,3,4),
  profit = c(12, 40, 19, 13)
)
```

```{r}
mutate(profits, avg_2_day_profit = slide_vec(profit, mean, .before=1))
```

- More on this in the section on functional programming!

Exercise: mutate()
===
type:prompt
incremental:true

`hwy` is the highway mileage and `cty` is the city mileage for each car in this dataset. Assuming I usually drive twice as many miles in the city as I do on the highway, can you compute my average mileage with each of these cars?

```{r}
mutate(mpg, avg_mpg = (2*cty + hwy)/3)
```

Exercise: mutate() and ggplot
===
type:prompt
incremental:true

In the first lecture we identified that sports cars (`class=="2seater"`) were outliers in the plot of displacement vs. highway mileage. Use `mutate()` as part of your answer to produce a plot where just the sports cars are a different color than the other cars:

```{r, echo=F, fig.width=10}
sports = mutate(mpg, sports_car = class=="2seater")
ggplot(sports) +
  geom_point(aes(x=displ, y=hwy, color=sports_car))
```

```{r, eval=F, tidy=F}
sports = mutate(mpg, sports_car = class=="2seater")
ggplot(sports) +
  geom_point(aes(x=displ, y=hwy, color=sports_car))
```

Exercise: putting it together
===
type:prompt
incremental:true

I'm considering buying a car. I know Toyotas and Subarus are reliable so I'd like for the car to be either a Toyota or Subaru. Besides that the only thing I really care about is overall fuel efficiency. I usually drive twice as many miles in the city as I do on the highway. Can you produce me a rank-ordered list of the top 10 cars that I should consider, from best to worst? I'd just like the make, model, transmission, year, and overall fuel efficiency.

```{r}
toyotas_and_subarus = filter(mpg, manufacturer=='toyota' | manufacturer=='subaru')
with_avg_mpg = mutate(toyotas_and_subarus, avg_mpg = (2*cty + hwy)/3)
sorted = arrange(with_avg_mpg, desc(avg_mpg))
top_10 = filter(sorted, row_number()<=10)
select(top_10, manufacturer, model, trans, year, avg_mpg)
```


Piping
===
type:section

Why pipe?
===
incremental:true

- in our last exercise, we used a number of different function applications to arrive at our answer.

```{r, eval=F, tidy=F}
toyotas_and_subarus = filter(mpg, manufacturer=='toyota' | manufacturer=='subaru')
with_avg_mpg = mutate(toyotas_and_subarus, avg_mpg = (2*cty + hwy)/3)
sorted = arrange(with_avg_mpg, desc(avg_mpg))
top_10 = filter(sorted, row_number()<=10)
select(top_10, manufacturer, model, trans, year, avg_mpg)
```

- we used temporary variables to keep our code clean. Compare to the same code using nested calls:

```{r, eval=F, tidy=F}
select(
  filter(
    arrange(
      mutate(
        filter(
          mpg, manufacturer=='toyota' | manufacturer=='subaru'),
        avg_mpg = (2*cty + hwy)/3),
      desc(avg_mpg)),
    row_number()<=10),
  manufacturer, model, trans, year, avg_mpg
)
```

- what makes either of these hard to read or understand?

The pipe operator
===

- tidyverse solves these problems with the pipe operator `%>%`

```{r, eval=F, tidy=F}
mpg %>%
  filter(manufacturer=='toyota' | manufacturer=='subaru') %>%
  mutate(avg_mpg = (2*cty + hwy)/3) %>%
  arrange(desc(avg_mpg)) %>%
  filter(row_number()<=10) %>%
  select(manufacturer, model, trans, year, avg_mpg)
```

- how does this compare with our code before? What do you notice?

```{r, eval=F, tidy=F}
toyotas_and_subarus = filter(mpg, manufacturer=='toyota' | manufacturer=='subaru')
with_avg_mpg = mutate(toyotas_and_subarus, avg_mpg = (2*cty + hwy)/3)
sorted = arrange(with_avg_mpg, desc(avg_mpg))
top_10 = filter(sorted, row_number()<=10)
select(top_10, manufacturer, model, trans, year, avg_mpg)
```

Pipe details
=================================================================
```{r eval=FALSE}
df1 %>% fun(x)
```
is converted into:
```{r eval=FALSE}
fun(df1, x)
```
- That is: the thing being piped in is used as the _first_ argument of `fun`.
- The tidyverse functions are consistently designed so that the first argument is a data frame, and the result is a data frame, so you can push a dataframe all the way through a series of functions

Pipe details
=================================================================
- The pipe works for all variables and functions, not just tidyverse functions
```{r}
c(1,44,21,0,-4) %>%
    sum() # instead of sum(c(1,44,21,0,-4))
```

```{r}
1 %>% `+`(1) # `+` is just a function that takes two arguments!
```

Piping to another position
===
- The pipe typically pipes into the first argument of a function, but you can use `.` to represent the object you're piping into the function
```{r}
mean %>%
  slide_vec(1:10, ., .before=2)
```
- Also notice how I've piped in a *function* to a function! (yes, functions are just objects like anything else in R)
- More about this in the functional programming section

Pipe to ggplot
===
type:prompt
incremental: true

- Run this code to see what it does. Then rewrite it using the pipe operator and get it to produce the same output.

```{r, eval=F, tidy=F}
outliers = filter(mpg, displ > 5, hwy > 21)
outliers = mutate(outliers, sports_car = class=="2seater")
ggplot(outliers) +
  geom_bar(aes(x=sports_car)) +
  scale_x_discrete("Class", labels=c("Other", "Sports Car")) +
  ggtitle("How many of the outliers are sports cars?")
```

```{r, eval=F, tidy=F}
mpg %>%
  filter(displ > 5, hwy > 21) %>%
  mutate(outliers, sports_car = class=="2seater") %>%
ggplot() +
  geom_bar(aes(x=sports_car)) +
  scale_x_discrete("Class", labels=c("Other", "Sports Car")) +
  ggtitle("How many of the outliers are sports cars?")
```

<!-- ^^  COMPLETE   ^^ -->
<!-- vv IN PROGRESS vv -->

===

summarize() computes desired summaires across rows
================================================================
```{r}
summarize(mtc, mpg_avg=mean(mpg))
```
- `summarize()` boils down the data frame according to the conditions it gets. In this case, it creates a data frame with a single column called `mpg_avg` that contains the mean of the `mpg` column
- Summaries can be very useful when you apply them to subgoups of the data, which we will soon see how to do.

summarize() computes desired summaires across rows
================================================================
- you can also pass in multiple conditions that operate on multiple columns at the same time
```{r}
summarize(mtc, # newlines not necessary, again just increase clarity
          mpg_avg = mean(mpg),
          mpg_2x_max = max(2*mpg),
          hp_mpg_ratio_min = min(hp/mpg))
```

dplyr verbs summary
========================================================

- `filter()` picks out rows according to specified conditions
- `select()` picks out columns according to their names
- `arrange()` sorts the row by values in some column(s)
- `mutate()` creates new columns, often based on operations on other columns
- `summarize()` collapses many values in one or more columns down to one value per column

All verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes).
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.

Computing over groups
==================================================================
type: section


group_by() groups data according to some variable(s)
==================================================================
First, let's load in some new data.
```{r}
data1 <- read_csv("http://stanford.edu/~sbagley2/bios205/data/data1.csv")
data1
```
- `<chr>` is short for "character string", which means text data
- Let's compute the mean weight for each gender.
- There are two values of gender in this data, so there will be two groups.
- The following builds a new version of the data frame that saves the grouping information:
```{r}
data1_by_gender <- group_by(data1, gender)
```
- We can now use the grouped data frame in further calculations.

group_by() groups data according to some variable(s)
==================================================================
```{r}
data1_by_gender
```
- The grouped data looks exactly the same, but under the hood, `R` knows that this is really two sub-data-frames (one for each group) instead of one.

Grouped summary: computing the mean of each group
===================================================================
```{r}
summarize(data1_by_gender, mean_weight = mean(weight))
```
- `summarize()` works the same as before, except now it returns two rows instead of one because there are two groups that were defined by `group_by(gender)`.
- The result also always contains colunmns corresponding to the unique values of the grouping variable

Grouping can also be applied across multiple variables
===================================================================
- This computes the mean weight and the mean age for each group:
```{r}
data1_by_gender_and_shoesize = group_by(data1, gender, shoesize)
summarize(data1_by_gender_and_shoesize,
          mean_weight = mean(weight),
          mean_age = mean(age))
```
- Now both `gender` and `shoesize` appear as columns in the result
- There are 3 rows because there are 3 unique combinations of `gender` and `shoesize` in the original data

Computing the number of rows in each group
=====================================================================
- The `n()` function counts the number of rows in each group:
```{r}
summarize(data1_by_gender, count = n())
```


Computing the number of distinct values of a column in each group
=====================================================================
- The `n_distinct()` function counts the number of distinct (unique) values in the specified column:
```{r}
summarize(data1_by_gender, n_sizes = n_distinct(shoesize))
```
- Note: `distinct()` filters out any duplicate rows in a dataframe. The equivalent for vectors is `unique()`


Exercise: count states in each region
=====================================================================
```{r}
state_data <- read_csv("http://stanford.edu/~sbagley2/bios205/data/state_data.csv")
state_data
```
- How many states are in each region?

Answer: count states in each region
=====================================================================
```{r}
state_data_by_region <- group_by(state_data, region)
summarize(state_data_by_region, n_states = n())
```

Challenge exercise: finding rows by group
===================================================================
`filter()` the grouped data in `data1_by_gender` to pick out the rows for the youngest male and female (hint: use `min()` and `==`).


Answer: finding rows by group
===================================================================
```{r}
filter(data1_by_gender, age==min(age))
```
- This shows how filter can be applied to grouped data. Instead of applying the condition across all the data, it applies it group-by-group.

============================================================
<div align="center">
<img src="https://miro.medium.com/max/1200/1*O4LZwd_rTEGY2zMyDkvR9A.png"; style="max-width:1500;"; class="center">
</div>