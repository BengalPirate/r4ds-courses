Tabular Data Foundations
========================================================
author: Alejandro Schuler, adapted from Steve Bagley and based on R for Data Science by Hadley Wickham
date: 2019
transition: none
width: 1680
height: 1050

```{r include=FALSE}
## better font size for slides
library(ggplot2)
theme_set(theme_grey(base_size = 22))
opts_chunk$set(collapse=TRUE,tidy=TRUE,prompt=TRUE,comment=NA,cache=FALSE)
opts_chunk$set(error=TRUE,warning=TRUE,message=TRUE)
```
<style>
.small-code pre code {
  font-size: 0.5em;
}
</style>


dplyr verbs
========================================================
The rest of this section shows the basic data frame functions ("verbs") in the `dplyr` package (part of `tidyverse`). Each operation takes a data frame and produces a new data frame.

- `filter()` picks out rows according to specified conditions
- `select()` picks out columns according to their names
- `arrange()` sorts the row by values in some column(s)
- `mutate()` creates new columns, often based on operations on other columns
- `summarize()` collapses many values in one or more columns down to one value per column

These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation.

All verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes).
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result. Letâ€™s dive in and see how these verbs work.

Filter rows with `filter()`
========================================================
```{r}
filter(mtc, mpg >= 25)
```
- This produces (and prints out) a new tibble, which contains all the rows where the mpg value in that row is greater than or equal to 25.
- There are only 6 rows in this data frame.
- There are still 11 columns.

Combining constraints in filter
========================================================
```{r}
filter(mtc, mpg >= 25, qsec < 19)
```
- This filters by the **conjunction** of the two constraints---both must be satisfied.
- Constraints appear as second (and third...) arguments, separated by commas.


Filtering out all rows
=========================================================
```{r}
filter(mtc, mpg > 60)
```
- If the constraint is too severe, then you will select **no** rows, and produce a zero row sized tibble.

Comparison operators
=========================================================
- `==` tests for equality (do not use `=`)
- `>` and `<` test for greater-than and less-than
- `>=` and `<=` are greater-than-or-equal and less-than-or-equal
- these can also be used directly on vectors outside of data frames
```{r}
c(1,5,-22,4) > 0
```

Logical conjunctions
=========================================================
```{r}
filter(mtc, mpg > 30 | mpg < 20)
```
- `|` stands for OR, `&` is AND
- as we have seen, separating conditions by a comma is the same as using `&` inside `filter()`
- these can be made into complex logical conditions

Logical conjunctions
=========================================================
```{r}
filter(mtc, !(mpg > 30 | mpg < 20))
```
- `!` is NOT, which negates the logical condition

Logical conjunctions
=========================================================
```{r}
filter(mtc, cyl %in% c(6,8)) # equivalent to filter(mtc, cyl==6 | cyl==8)
```
- `%in%` returns true for all elements of the thing on the left that are also elements of the thing on the right

Exercise: cars with powerful engines
==========================================================
- How many cars have engines with horsepower (`hp`) greater than 200?


Answer: cars with powerful engines
===========================================================
```{r}
filter(mtc, hp > 200)
```
- Answer: 7


Exercise: filtering rows
========================================================
- List all cars with `mpg` between 15 and 20.


Answer: filtering rows
=========================================================
```{r}
filter(mtc, mpg > 15, mpg < 20)
```


Filtering by row number
==========================================================
```{r}
filter(mtc, row_number()<=3)
```
- use `row_number()` to get specific rows. This is more useful once you have sorted the data in a particular order, which we will soon see how to do.

Sampling rows
==========================================================
```{r}
sample_n(mtc, 5)
```
- You can use `sample_n()` to get `n` randomly selected rows if you don't have a particular condition you would like to filter on.
- `sample_frac()` is similar
- do `?sample_n()` to see how you can sample with replacement or with weights

select() subsets columns by name
=========================================================
```{r}
select(mtc, mpg, qsec, wt)
```
- The select function will return a subset of the tibble, using only the requested columns in the order specified.

select() subsets columns by name
=========================================================
- `select()` can also be used with handy helpers like `starts_with()` and `contains()`
```{r}
select(mtc, starts_with("m"))
```

select() subsets columns by name
=========================================================
- `select()` can also be used with handy helpers like `starts_with()` and `contains()`
```{r}
select(mtc, hp, contains("m"))
```
- The quotes around the letter `"m"` make it a character string (or string for short). If we did not do this, `R` would think it was looking for a variable called `m` and not just the plain letter.
- We don't have to quote the names of columns (like `hp`) because the `tidyverse` functions know that we are working within the dataframe and thus treat the column names like they are variables in their own right

select() subsets columns by name
=========================================================
- `select()` can also be used to select everything **except for** certain columns
```{r}
select(mtc, -contains("m"), -hp)
```

pull() is a friend of select()
=========================================================
- `select()` has a friend called `pull()` which returns a vector instead of a (one-column) data frame
```{r}
select(mtc, hp)
pull(mtc, hp)
```

Saving the result
=========================================================
```{r}
filter(mtc, row_number()==1)
head(mtc)
```
- `select()` and `filter()` are functions, so they do not modify their input. You can see `mtc` is unchanged after calling `filter()` on it. This holds for functions in general.

Saving the result
=========================================================
- To save a new version of mtc, use a variable
```{r}
mtc_first_row = filter(mtc, row_number()==1)
mtc_first_row
```

Combining filtering and selecting
=========================================================
- If the result of the operation will only be used by one other function, you can nest the calls:
```{r}
# tmp = select(mtc, mpg, qsec, wt)
# filter(tmp, mpg >= 25)
filter(select(mtc, mpg, qsec, wt), mpg >= 25)
```


arrange() sorts rows
===========================================================
- `arrange` takes a data frame and a column, and sorts the rows by the values in that column (ascending order).
```{r}
powerful <- filter(mtc, hp > 200)
arrange(powerful, mpg)
```

Arrange can sort by more than one column
===========================================================
- This is useful if there is a tie in sorting by the first column.
```{r}
arrange(powerful, gear, disp)
```


Use the desc function to sort by descending values
===========================================================
```{r}
arrange(powerful, desc(mpg))
```

Exercise: top 5 mpg cars
===========================================================
Use `arrange()` and `filter()` to get the data for the 5 cars with the highest mpg.

Answer: top 5 mpg cars
================================================================
```{r}
filter(arrange(mtc, desc(mpg)), row_number()<=5) # "nesting" the calls to filter and arrange
```
or
```{r}
cars_by_mpg = arrange(mtc, desc(mpg)) # using a temporary variable
filter(cars_by_mpg, row_number()<=5)
```

mutate() creates new columns
================================================================
```{r}
mtc_vars_subset = select(mtc, mpg, hp)
mutate(mtc_vars_subset, gpm = 1/mpg)
```
- This uses `mutate` to add a new column to which is the reciprocal of `mpg`.
- The thing on the left of the `=` is a new name that you make up which you would like the new column to be called
- The expresssion on the right of the `=` defines what will go into the new column
-mutate() can create multiple columns at the same time and use multiple columns to define a single new one

mutate() can create multiple new columns at once
================================================================
```{r}
mutate(mtc_vars_subset, # the newlines make it more readable
      gpm = 1/mpg,
      mpg_hp_ratio = mpg/hp)
```
- As before, the result of this function is only saved if you assign it to a variable. In this example, `mtc_vars_subset` is unchanged after the mutate.

mutate() for data type conversion
===
- Data is sometimes given to you in a form that makes it difficult to do operations on
```{r}
df = tibble(number = c("1", "2", "3"))
mutate(df, number_plus_1 = number + 1)
```

- `mutate()` is also useful for converting data types, in this case text to numbers
```{r}
mutate(df, number = as.numeric(number))
```
- if you save the result into a column that already exists, it will be overwritten

summarize() computes desired summaires across rows
================================================================
```{r}
summarize(mtc, mpg_avg=mean(mpg))
```
- `summarize()` boils down the data frame according to the conditions it gets. In this case, it creates a data frame with a single column called `mpg_avg` that contains the mean of the `mpg` column
- Summaries can be very useful when you apply them to subgoups of the data, which we will soon see how to do.

summarize() computes desired summaires across rows
================================================================
- you can also pass in multiple conditions that operate on multiple columns at the same time
```{r}
summarize(mtc, # newlines not necessary, again just increase clarity
          mpg_avg = mean(mpg),
          mpg_2x_max = max(2*mpg),
          hp_mpg_ratio_min = min(hp/mpg))
```

dplyr verbs summary
========================================================

- `filter()` picks out rows according to specified conditions
- `select()` picks out columns according to their names
- `arrange()` sorts the row by values in some column(s)
- `mutate()` creates new columns, often based on operations on other columns
- `summarize()` collapses many values in one or more columns down to one value per column

All verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes).
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.

Computing over groups
==================================================================
type: section


group_by() groups data according to some variable(s)
==================================================================
First, let's load in some new data.
```{r}
data1 <- read_csv("http://stanford.edu/~sbagley2/bios205/data/data1.csv")
data1
```
- `<chr>` is short for "character string", which means text data
- Let's compute the mean weight for each gender.
- There are two values of gender in this data, so there will be two groups.
- The following builds a new version of the data frame that saves the grouping information:
```{r}
data1_by_gender <- group_by(data1, gender)
```
- We can now use the grouped data frame in further calculations.

group_by() groups data according to some variable(s)
==================================================================
```{r}
data1_by_gender
```
- The grouped data looks exactly the same, but under the hood, `R` knows that this is really two sub-data-frames (one for each group) instead of one.

Grouped summary: computing the mean of each group
===================================================================
```{r}
summarize(data1_by_gender, mean_weight = mean(weight))
```
- `summarize()` works the same as before, except now it returns two rows instead of one because there are two groups that were defined by `group_by(gender)`.
- The result also always contains colunmns corresponding to the unique values of the grouping variable

Grouping can also be applied across multiple variables
===================================================================
- This computes the mean weight and the mean age for each group:
```{r}
data1_by_gender_and_shoesize = group_by(data1, gender, shoesize)
summarize(data1_by_gender_and_shoesize,
          mean_weight = mean(weight),
          mean_age = mean(age))
```
- Now both `gender` and `shoesize` appear as columns in the result
- There are 3 rows because there are 3 unique combinations of `gender` and `shoesize` in the original data

Computing the number of rows in each group
=====================================================================
- The `n()` function counts the number of rows in each group:
```{r}
summarize(data1_by_gender, count = n())
```


Computing the number of distinct values of a column in each group
=====================================================================
- The `n_distinct()` function counts the number of distinct (unique) values in the specified column:
```{r}
summarize(data1_by_gender, n_sizes = n_distinct(shoesize))
```
- Note: `distinct()` filters out any duplicate rows in a dataframe. The equivalent for vectors is `unique()`


Exercise: count states in each region
=====================================================================
```{r}
state_data <- read_csv("http://stanford.edu/~sbagley2/bios205/data/state_data.csv")
state_data
```
- How many states are in each region?


Answer: count states in each region
=====================================================================
```{r}
state_data_by_region <- group_by(state_data, region)
summarize(state_data_by_region, n_states = n())
```


Challenge exercise: finding rows by group
===================================================================
`filter()` the grouped data in `data1_by_gender` to pick out the rows for the youngest male and female (hint: use `min()` and `==`).


Answer: finding rows by group
===================================================================
```{r}
filter(data1_by_gender, age==min(age))
```
- This shows how filter can be applied to grouped data. Instead of applying the condition across all the data, it applies it group-by-group.

Chaining: combining a sequence of function calls
=================================================================
type: section

Both nesting and temporary variables can be ugly and hard to read
=================================================================
- In this expression, the result of `summarize` is used as an argument to `arrange`.
- The operations are performed "inside out": first `summarize`, then `arrange`.
```{r eval=FALSE}
arrange(summarize(group_by(state_data, region), sd_area = sd(area)), sd_area)
```
- We could store the first result in a temporary variable:
```{r}
state_data_by_region <- group_by(state_data, region)
region_area_sds <- summarize(state_data_by_region, sd_area = sd(area))
arrange(region_area_sds, sd_area)
```


Chaining using the pipe operator
=================================================================
- Or, we can use a new operator, `%>%`, to "pipe" the result from the first
function call to the second function call.
```{r}
state_data %>%
  group_by(region) %>%
  summarize(sd_area = sd(area)) %>%
  arrange(sd_area)
```

- This makes explicit the flow of data through operations:
  - Start with `state_data`
  - group it by region
  - summarize by region, computing `sd_area`
  - arrange rows by `sd_area`
- The code reads like instructions that a human could understand
- putting the function calls on different lines also improves readability

Pipe: details
=================================================================
```{r eval=FALSE}
df1 %>% fun(x)
```
is converted into:
```{r eval=FALSE}
fun(df1, x)
```
- That is: the thing being piped in is used as the _first_ argument of `fun`.
- The tidyverse functions are consistently designed so that the first argument is a data frame, and the result is a data frame, so piping always works as intended.

Pipe: details
=================================================================
- However, the pipe works for all variables and functions, not just tidyverse functions
```{r}
c(1,44,21,0,-4) %>%
    sum()
sum(c(1,44,21,0,-4))
1 %>% `+`(1) # `+` is just a function that takes two arguments!
```

Piping to another position
===
- The pipe typically pipes into the first argument of a function, but you can use the `.` syntax to send the argument elsewhere:
```{r}
values = c(1,2,3,NA)

TRUE %>%
  mean(values, na.rm=.)
```
- This is typically not done, but can be a handy shortcut in many situations

dplyr cheatsheet
============================================================
<div align="center">
<img src="https://www.rstudio.com/wp-content/uploads/2018/08/data-transformation.png", height=1000, width=1400>
</div>

Visualization basics
============================================================
type: section

ggplot2
=============================================================
- `ggplot2` is a very powerful graphics package.
- gg stands for "grammar of graphics"
- It was installed and loaded as part of `tidyverse`.
- Otherwise, you must do the following:
```{r eval=FALSE}
install.packages("ggplot2")
library("ggplot2")
```
```{r include=FALSE}
## better font size for slides
theme_set(theme_grey(base_size = 22))
```


A simple scatterplot
=============================================================
```{r}
ggplot(data = mtc, mapping = aes(x = hp, y = mpg)) +
  geom_point()
```
- Note that, although the package is named `ggplot2`, the function is called simply `ggplot()`

How to call ggplot
==============================================================
```{r, prompt=FALSE,eval=FALSE,tidy=FALSE}
ggplot(data = mtc, mapping = aes(x = hp, y = mpg)) + geom_point()
```
- `data = mtc`: this tells which tibble contains the data to be plotted
- `mapping = aes(x = hp, y = mpg)`: use the data in the hp column on x-axis, mpg column on y-axis
- `geom_point()`: plot the data as points
- Note that you can use positional instead of named arguments to make this expression shorter:
```{r prompt=FALSE,eval=FALSE}
ggplot(mtc, aes(hp, mpg)) +
  geom_point()
```
- The use of "+" to glue these operations together will be explained later.


Change points to lines
===============================================================
```{r}
ggplot(mtc, aes(hp, mpg)) +
  geom_line()
```
- This is pretty ugly. Line plots are better for time series.


Fit straight line to points
===============================================================
```{r}
ggplot(mtc, aes(hp, mpg)) +
  geom_point() +
  geom_smooth(method="lm")
```
- `"lm"` means "linear model," which is a least-squares regression line.
- The gray band is the confidence interval.


Fit smooth line to points
================================================================
```{r}
ggplot(mtc, aes(hp, mpg)) +
  geom_point() +
  geom_smooth(method="loess")
```
- "loess" fits a collection of tiny regression lines, then glues them together.
- This is a better approximation than a straight line for these data.


Fit smooth line to points without standard error
================================================================
```{r}
mtc %>% # with the pipe
ggplot(aes(hp, mpg)) +
  geom_point() +
  geom_smooth(method="loess", se=FALSE)
```
- `se = FALSE` means do not plot the confidence band (using the standard error)

Plotting categorical variables
====================================================================
- `gender` is a discrete variable, with two values.
```{r}
data1 %>%
  group_by(gender) %>%
  summarize(mean_age=mean(age), mean_weight=mean(weight)) %>%
ggplot(aes(gender, mean_weight)) +
  geom_col()
```
- `geom_col()` is used to make a bar plot. Height of bar is the value for that group.

The grammar of graphics
============================================================
- Most graphics systems are a large collection of functions to call to
construct a graph piece by piece.
- `ggplot2` is different, and is based on the idea of a "grammar of
graphics," a set of primitives and rules for combining them in a way
that makes sense for plotting data.
- This perspective is quite powerful, but requires learning a bit of
vocabulary and a new way of thinking about graphics.


The ggplot2 model (simplified version)
============================================================
1. supply data frame (rows of observations, columns of variables)
2. use `aes` to map from variables (columns in data frame) to
aethetics (visual properties of the plot): x, y, color, size,
shape, and others.
3. choose a `geom`. This determines the type of the plot: point (a
scatterplot), line (line graph or line chart), bar (barplot), and
others.
4. choose a `stat` (statistical transformation): often `identity` (do
no transformation), but can be used to count, bin, or summarize
data (e.g., in a histogram).
5. choose a `scale`. This converts from the units used in the data
frame to the units used for display.
6. provide optional facet specification.

ggplot2 cheatsheet
============================================================
<div align="center">
<img src="https://www.rstudio.com/wp-content/uploads/2018/08/data-visualization-2.1.png", height=1000, width=1400>
</div>

Putting it together
=================================================================
type: section

Exercise: Is there a linear relationship between hp and 1/mpg?
=================================================================
- Use `ggplot` to look for a linear relationship between `hp` and `1/mpg` in our `mtc` data


Answer: Is there a linear relationship between hp and 1/mpg?
=================================================================
```{r}
ggplot(mtc, aes(hp, 1/mpg)) +
  geom_point() +
  geom_smooth(method="lm", se=FALSE)
```
- So, probably "yes"

Answer: Is there a linear relationship between hp and 1/mpg?
=================================================================
- Could also have done:
```{r, eval=F}
mtc %>%
  mutate(gpm = 1/mpg) %>%
ggplot(aes(hp, gpm)) +
  geom_point() +
  geom_smooth(method="lm", se=FALSE)
```

Exercise: orange trees
=================================================================
```{r}
orange <- as_tibble(Orange) # this data is pre-loaded into R
```
1. Pull out the data for tree 2 only
2. Plot circumference versus age for those data

Answer: orange trees
==================================================================
```{r}
orange %>%
  filter(Tree == 2) %>%
ggplot(aes(age, circumference)) +
  geom_point()
```


Exercise: more orange trees
============================================================
1. Pull out the data for tree 2 where `age > 1000`
2. Plot circumference versus age for those data

Answer: more orange trees
==================================================================
```{r}
orange %>%
  filter(Tree == 2, age > 1000) %>%
ggplot(aes(age, circumference)) +
  geom_point()
```


Exercise: even more orange trees
============================================================
- Add a new column called `circum_in` which is the circumference in inches, not in millimeters.


Answer: even more orange trees
=================================================================
```{r}
mutate(orange, circum_in = circumference/(10 * 2.54))
```


Exercise: compute mean area per region
=====================================================================
Use the `state_data` data frame for this exercise.
- What is the mean area for each region?
- Sort the result by decreasing area.


Answer: compute mean area per region
=====================================================================
```{r}
state_data %>%
  group_by(region) %>%
  summarize(mean_area = mean(area)) %>%
  arrange(desc(mean_area))
```


Exercise: Sort the regions by area range
=====================================================================
- Sort the regions by the difference between the areas of the largest and smallest state in each region.


Answer: Sort the regions by area range
=====================================================================
```{r}
state_data %>%
  group_by(region) %>%
  summarize(area_range = max(area) - min(area)) %>%
  arrange(area_range)
```


Adding new column with data by group
=====================================================================
```{r}
state_data2 <- state_data %>%
  group_by(region) %>%
  mutate(region_mean = mean(area))
state_data2
```
- This computes the mean area for each region, and places those values in a new column.
- The `region_mean` column has 50 values, one for each state, depending on the region the state is in.


Exercise: closest to region mean
=====================================================================
- Which state is closest to the mean of its region?


Answer: closest to region mean
=====================================================================
```{r}
state_data2 %>%
    mutate(diff = abs(area-region_mean)) %>%
    filter(diff == min(diff))
```

- We should use `ungroup()` to undo the `group_by()` so that the `filter()` is applied across the whole data frame and not region-by-region

```{r}
state_data2 %>%
    mutate(diff = abs(area-region_mean)) %>%
    ungroup() %>%
    filter(diff == min(diff))
```
- Answer: Florida



Exercise: smallest state in each region
=====================================================================
- What is the smallest state in each region?


Answer: smallest state in each region
=====================================================================
```{r}
state_data %>%
    group_by(region) %>%
    filter(area == min(area))
```


Relational data and joins
============================================================
type: section
```{r}
# install.packages("nycflights13")
library(nycflights13)
```


Relational data
=====================================================================
class: small-code

```{r}
head(flights)
```
```{r}
head(airports)
```

***

```{r}
head(planes)
```
```{r}
head(weather)
```

Relational data
===

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/245292d1ea724f6c3fd8a92063dcd7bfb9758d02/5751b/diagrams/relational-nycflights.png">
</div>

- `flights` connects to `planes` via a single variable, `tailnum`.
- `flights` connects to `airlines` through the `carrier` variable.
- `flights` connects to `airports` in two ways: via the `origin` and `dest` variables.
- `flights` connects to `weather` via `origin` (the location), and `year`, `month`, `day` and `hour` (the time).

An example join
===
- Imagine we want to add the full airline name to some columns from `flights`
```{r}
flights %>%
  select(tailnum, origin, dest, carrier) %>%
  inner_join(airlines, by="carrier")
```

Joins
===
```{r}
x <- tibble(
  key = c(1,2,3),
  val_x = c("x1","x2","x3")
)
y <- tibble(
  key = c(1,2,4),
  val_y = c("y1","y2","y3")
)
```

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/108c0749d084c03103f8e1e8276c20e06357b124/5f113/diagrams/join-setup.png">
</div>

***

```{r}
inner_join(x, y, by="key")
```
- An inner join matches pairs of observations when their keys are equal
- the column that is joined on is specified with the named argument `by="column"`

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/3abea0b730526c3f053a3838953c35a0ccbe8980/7f29b/diagrams/join-inner.png">
</div>

Duplicate keys
===
```{r}
x <- tibble(
  key = c(1,2,2,3),
  val_x = c("x1","x2","x3","x4")
)
y <- tibble(
  key = c(1,2,2,4),
  val_y = c("y1","y2","y3","y4")
)
```

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/d37530bbf7749f48c02684013ae72b2996b07e25/37510/diagrams/join-many-to-many.png">
</div>

***

```{r}
inner_join(x, y, by="key")
```

When keys are duplicated, multiple rows can match multiple rows, so each possible combination is produced

Specifying the keys
===
```{r}
inner_join(airports, flights, by="origin")
```
- Why does this fail?

Specifying the keys
===
- When keys have different names in different dataframes, the syntax to join is:
```{r}
inner_join(airports, flights, by=c("faa"="origin"))
```

Exercise: finding planes
===
Use joins to find the models of airplane that fly into Seattle Tacoma Intl.

Answer: finding planes
===
Use joins to find the models of airplane that fly into Seattle Tacoma Intl.
```{r}
airports %>%
  filter(name=="Seattle Tacoma Intl") %>%
  inner_join(flights, by=c("faa"="dest")) %>%
  inner_join(planes, by="tailnum") %>%
  select(model) %>%
  distinct()
```

Other joins
===
- A left join keeps all observations in `x`.
- A right join keeps all observations in `y`.
- A full join keeps all observations in `x` and `y`.

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/9c12ca9e12ed26a7c5d2aa08e36d2ac4fb593f1e/79980/diagrams/join-outer.png">
</div>

- Left join should be your default
  - it looks up additional information in other tables
  - preserves all rows in the table you're most interested in

***

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png">
</div>

Joining on multiple columns
===
- It is often desirable to find matches along more than one column
```{r}
flights %>%
  select(tailnum, year:day, hour, origin) %>%
  left_join(weather, by=c("year", "month", "day", "hour", "origin")) %>%
  head(3)
```
- This is also possible if the columns have different names
```{r, eval=F}
flights %>%
  select(tailnum, year:day, hour, origin) %>%
  rename(departure = origin) %>%
  left_join(weather, by=c("year", "month", "day", "hour", "departure"="origin"))
```

Join problems
===
- Joins can be a source of subtle errors in your code
- check for `NA`s in variables you are going to join on
- make sure rows aren't being dropped if you don't intend to drop rows
  - checking the number of rows before and after the join is not sufficient. If you have an inner join with duplicate keys in both tables, you might get unlucky as the number of dropped rows might exactly equal the number of duplicated rows
- `anti_join()` and `semi_join()` are useful tools (filtering joins) to diagnose problems
  - `anti_join()` keeps only the rows in `x` that *don't* have a match in `y`
  - `semi_join()` keeps only the rows in `x` that *do* have a match in `y`

Exercise: nonexistent planes
====
It appears some of the `tailnum`s in `flights` do not appear in `planes`. Is there something those flights have in common that might help us diagnose the issue?

Answer: nonexistent planes
====
```{r}
bad_flight_carrier_count = flights %>%
  anti_join(planes, by="tailnum") %>%
  sample_n(10)
```

Answer: nonexistent planes
====
It appears some of the `tailnum`s in `flights` do not appear in `planes`. Is there something those flights have in common that might help us diagnose the issue?
```{r}
bad_flight_carrier_count = flights %>%
  anti_join(planes, by="tailnum") %>%
  count(carrier) %>%
  arrange(desc(n))
bad_flight_carrier_count
```

- `count(x)` is a shortcut for `group_by(x) %>% summarize(n=n())`

***

Let's compare the counts of airlines with missing planes to the counts of airlines across all flight data
```{r}
flight_carrier_count = flights %>%
  count(carrier) %>%
  arrange(desc(n))
flight_carrier_count
```

Answer: nonexistent planes
====
We can already see the trend but let's clean it up a bit
```{r, eval=F}
flight_carrier_count %>%
  left_join(bad_flight_carrier_count,
            by="carrier",
            suffix=c("_all", "_bad")) %>%
  replace_na(list(n_bad=0)) %>%
  mutate(bad_ratio = n_bad/n_all) %>%
  left_join(airlines, by="carrier") %>%
ggplot(aes(y=name, x=bad_ratio)) +
  geom_point()
```

***

```{r, echo=F}
flight_carrier_count %>%
  left_join(bad_flight_carrier_count,
            by="carrier",
            suffix=c("_all", "_bad")) %>%
  replace_na(list(n_bad=0)) %>%
  mutate(bad_ratio = n_bad/n_all) %>%
  left_join(airlines, by="carrier") %>%
ggplot(aes(y=name, x=bad_ratio)) +
  geom_point()
```

- Envoy Air and American Airlines are the culprits!


Reproducible analysis
============================================================
type: section


Reproducible analysis
========================================================

The goal of reproducible analysis is to produce a computational
artifact that others can view, scrutinize, test, and run, to convince
themselves that your ideas are valid. (It's also good for you to be as
skeptical of your work.) This means you should write code to be run
more than once and by others.

Doing so requires being organized in several ways:

- Combining text with code (the focus of this section)
- Project/directory organization
- Version control

The problem
========================================================
- You write text in a word processor.
- You write code to compute with data and produce output and
graphics.
- These are performed using different software.
- So when integrating both kinds of information into a notebook,
report, or publication, it is very easy to make mistakes,
copy/paste the wrong version, and have information out of sync.


A solution
========================================================
- Write text and code in the same file.
- Use special syntax to separate text from code.
- Use special syntax for annotating the text with formatting
operations (if desired).
- RStudio can then:
1. run the code blocks,
2. insert the output and graphs at the correct spot in the text,
3. then call a text processor for final formatting.
- This whole process is called "knitting".
- (live demo)
- jupyter notebooks (outside of RStudio) are an alternative for doing the same thing


R Markdown: The special syntax for formatting text
========================================================
- RStudio supports a simple and easy-to-use format called "R Markdown".
- This is a very simple markup language:
- use * or _ around italics.
- use ** or __ around bold.
- Markdown Quick Reference (RStudio internal help)
- [Introduction to R Markdown](http://shiny.rstudio.com/articles/rmarkdown.html)
- [R Markdown web page](http://rmarkdown.rstudio.com/)
- [R Markdown Cheat Sheet](http://shiny.rstudio.com/articles/rm-cheatsheet.html)
